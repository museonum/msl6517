title: MSL6517-06
description: emchateau UdeM
theme: presentation/theme/remark-dark-em.css
name: inverse
layout: true
class: inverse

---

name: index

class: center middle

# Notions élémentaires d’informatique documentaire pour le monde muséal et patrimonial - 2

### MSL6517 – automne 2023 | Emmanuel Château

.footnote[<https://studium.umontreal.ca/course/view.php?id=254809>]

---
layout: false


class: center middle

# Introduction

???

Introduction sur les modèles métiers

- rappels séance précédente
- identification de catégories d’informations
- discrétiser l’information

Au cours de la dernière séance, nous avons examiné quatre grands modèles conceptuels de données et commencé à envisager leur traduction dans des différents formats informatiques.

En continuant l’examen des modèles de données en sciences de l’information et de la documentation, nous allons en particulier aborder aujourd’hui le **modèle relationnel**.

Après avoir envisagé l’utilisation des systèmes d’information informatiques.

- Compétence conceptuelle

  Compréhension de quatre modèles de données (données tabulaires, bases de données, XML et RDF).

- Compétence technique

  SQL, Schémas E-R, XML Schema et SPARQL

- Outils

  Outils : MySQL, Exchanger, XML Editor, DBpedia

---

template: inverse
class: middle center

# Bases de données relationnelles

???

---

## Définitions

Bases de données

> Ensemble structuré d’éléments d’**informations** souvent agencés sous forme de **tables**, dans lesquelles les **données** sont organisées selon certains critères en vue de permettre leur exploitation pour répondre aux besoins d’information d’une organisation (*Database*). 

Gilles Roy. 2007. *Conception de bases de données avec UML*. Québec : Presses de l’Université du Québec.

???

### Quelques définitions

Bases de données

> Ensemble structuré d’éléments d’informations souvent agencés sous forme de tables, dans lesquelles les données sont organisées selon certains critères en vue de permettre leur exploitation pour répondre aux besoins d’information d’un organisme. 

Une base de données permet de stockée et d’accéder à des données structurées, semi-structurées ou des données brutes en rapport avec un domaine d’activité. Il existe plusieurs types de bases de données. À partir des années 80, le modèle relationnel et langages de manipulation et de requête de données SQL se sont largement imposés, mais depuis le milieu des années 2000, des modèles de bases de données orientés document (dites NoSQL) ont également fait leur apparition.

---

## Application de base de données

> Utilisation de moyens informatique pour répondre à un besoin déterminer en faisant appel à une ou plusieurs bases de données à travers un SGBD Système de gestion de base de données.

## Système de gestion de bases de données (SGBD)

> Logiciel, le plus souvent produit par un éditeur commercial, qui gère et contrôle l’accès à une base de données, assurant ainsi une interface normalisée entre les applications et les bases de données (*Database management system*).

Gilles Roy. 2007. *Conception de bases de données avec UML*. Québec : Presses de l’Université du Québec.

???

### Quelques définitions

Bases de données

> Ensemble structuré d’éléments d’informations souvent agencés sous forme de tables, dans lesquelles les données sont organisées selon certains critères en vue de permettre leur exploitation pour répondre aux besoins d’information d’un organisme. 

Application de base de donnée

> Moyen informatique pour répondre à un besoin déterminer en faisant appel à une ou plusieurs bases de données à travers un SGBD Système de gestion de base de données.

Système de gestion de bases de données (SGBD)

> Logiciel, le plus souvent produit par un éditeur commercial, qui gère et contrôle l’accès à une base de données, assurant ainsi une interface normalisée entre les applications et les bases de données (*Database management system*).

Gilles Roy. 2007. Conception de bases de données avec UML. Québec : Presses de lUniversité du Québec.

---

## Applications

Utilisation partout aujourd’hui

- Dans le commerce électronique, la banque, etc.
- Gestion électronique des documents (GED) et Système de gestion de contenus (CMS)
- Support de décision

Logiciels, Systèmes de gestion de base de données :

- [Mysql](https://www.mysql.com) | [SQLite](https://www.sqlite.org) | [PostgreSQL](https://www.postgresql.org)
- [Microsoft SQL server](https://www.microsoft.com/en-ca/sql-server/) (propriétaire) | Oracle (propriétaire) | [FileMaker](https://www.claris.com/filemaker/)
- ...

???

Les bases de données relationnelles sont utilisées partout, qu’il s’agisse du commerce électronique, de la banque, des assurances, de l’épidémiologie, en passant par la gestion électronique documents (GED), jusqu’aux systèmes de gestion de contenus pour la publication des sites web.

Il existe de très nombreuses solutions logicielles de gestion de bases de données relationnelles, qui peuvent être libres et open source, ou propriétaires. Les système de gestion de bases de données rélationnelles libres et open source MySQL, SQLite et PostgreSQL sont les plus populaires en particulier dans le domaine du développement web. Mias plusieurs solutions propriétaires sont également déployées dans certains secteurs métiers, à l’intar de Microsoft SQL server, d’Oracle, de 4D ou de FileMaker.

Certains cas d’utilisation nécessitent des systèmes de bases de données orientés documents, en graphe ou tabulaires.

---

## Le modèle relationnel d’Edgar Frank Codd

Edgard Frank Codd (1923-2003)

Description du modèle en 1969

> *« Derivability, Redundancy, and Consistency of Relations Stored in Large Data Banks », IBM Research Report RJ599*.

Publication scientifique en 1970

> *« A Relational Model of Data for Large Shared Data Banks" ("Un modèle de données relationnel pour de grandes banques de données partagées"), CACM 13, No. 6, June 1970*.

Algèbre relationnel, théorème de Codd (1971) et théorie des bases de données.

???

Le modèle relation a été développé par Edgar Frank Codd dans les années 1960-1970. Celui-ci permet de décrire les relations entre les données de façons logique et mathématique avec l’utilisation d’un algèbre relationnel. Un premier rapport technique est publié en 1969 et donne lieu à une publication scientifique en 1970. Le théorème de Codd sera au fondement de la théorie des bases de données. 

- *« Derivability, Redundancy, and Consistency of Relations Stored in Large Data Banks », IBM Research Report RJ599*. 
- *« A Relational Model of Data for Large Shared Data Banks" ("Un modèle de données relationnel pour de grandes banques de données partagées"), CACM 13, No. 6, June 1970*.

Il s’agit d’**un modèle abstrait**, indépendant de toute implémentation informatique. C’est toute la force de ce modèle puisqu’il rend possible le développement d’un langage de haut niveau pour la représentation et la manimulation des données.

Dans le modèle de base de données relationnelle, une table ou relation contient plusieurs attributs et plusieurs enregistrements appelés *tuples*. Le modèle décrit les notions de :

- Relation
- d’intégrité relationnelle
- d’intégrité référentielle
- formes normales
- Redondance et consistance

Opérateurs relationnels

D’après Codd, on peut manipuler une base de données définie selon le modèle relationnel avec un ensemble d’opérations formelles sur les relations. Ces opérations dites « relationnelles » sont définies par cinq opérateurs de base qui sont l’union, la différence, la sélection, la projection et le produit cartésien.

Le modèle relationnel développé par Codd entre 1969 et 1973 connaîtra un succès immédiat. Dès 1974, un premier système de base de données relationnelles nommé INGRES est créé par Michael Stonebraker et Eugene Wong.

voir si donne plus de détails <https://fr.wikipedia.org/wiki/Modèle_relationnel>

<https://fr.wikipedia.org/wiki/Forme_normale_(bases_de_données_relationnelles)>

<https://fr.wikipedia.org/wiki/Théorème_de_Codd>

---

layout:false

## Le modèle relationnel : une abstraction

- Indépendance entre les données et les applications
- Contrôle centralisé des données pour éviter les redondances
- Partage des données et accès concurrents
- Gestion de la cohérence et de l’intégrité des données
- Langage de représentation, langage de requête (SQL)

???

Le modèle relationnel, est avant tout une abstraction. C’est sa force et la principale raison de son succès.

### Indépendance entre les données et les applications

Tout est représenté de la même manière, indépendamment des implémentations. Précédemment, les systèmes étaient plus dépendant de l’organisation physique des documents. Cette séparation du modèle et de son implémentation simplifie grandement le développement d’applications puisqu’il n‘est pas nécessaire de développer les aspects structurels des fichiers. Si la structure de la base de données est amenée à changer, de même, il n’est pas nécessaire de modifier les programme. 

= grande productivité

### Contrôle centralisé des données pour éviter toute redoncance

Le SGBD doit intégrer dans un même espace de stockage plusieurs fichiers de manière à éviter toute redondance. Il n’est pas nécessaire dans un SI qu’une information soit dupliquée, cela favorise la mise mise à jour si l’information doit être modifiée.

### Partage des données et accès concurrents

> La centralisation du stockage des données destinée à assurer l’unicité de la saisie et de la validation des données a pour corollaire la mise en place de mécanismes techniques qui vont assurer aux utilisateurs un partage équitable de ces données, sans risque de concurrence, mais qui vont aussi empêche des accès non autorisés.

- mécanismes d’accès concurrents pour plusieurs utilisateurs
- mécanismes destinés à faire ensorte que des opérations simultanées ne mènent pas à des incohérence ((premier arrivé premier servi, verrou).

## Gestion de la cohérence et de l’intégrité des données

> "Les SGBD doivent pouvoir gérer le processus de mise à jour d’un ensemble de données comme un tout indissociable pour garantir la cohérnece interne de la base de données." = mécanisme d’atomicité de la transaction.

ex. journal des transactions, gestion des pannes, etc.

> "L’intégrité des données réfère à la nécessité de voir appliquer automatiquement par le SGBD des contraintes sur la validité d’une donnée. Là encore, il s’agit d’une responsabilité qui incombe aux condepteurs d’une bas de données."

> "Contrainte d’intégrité des données : Ensemble de règles, définies par le concepteur d’une base de données, qui devront d’intégrité en tout temps être respectées par les données de la base de données. Ces règles sont gérées par le SGBD qui en assure l’application et informe l’utilisateur lorsque l’une d’elles est transgressée (*Integrity contraint*).

Ces contraintes d’intégrité des données sont définies au moment de la conception d‘une base de données afin d’écarter, lors de la saisie toute valeur inacceptable.

- contraintes d’intégrité sémnatique qui concerne la signification d’une données
- contraintes d’intégrité référentielle qui concerne les avleurs que peuvent prendre deux données associées dans la même base de données

La **notion d’intégrité des données** réfère à la nécessité de voir appliquer automatiquement par le SGBD des contraintes sur la validité d’une donnée. 

## Contrainte d’intégrité, d’unicité, intégrité référentielle

Ensemble de règles définies qui devront être respectées par le SGBD

- Contrainte d’unicité de l’entité : Clef primaire ne peuvent être nulle
- Contrainte d’intégrité référentielle : Il doit y avoir aucune valeur clef étrangère non remplie

## Règles formelles (formes normales)

Le modèle de donné est associé à la définition de plusieurs règles formelles (ou formes normales) qui permettent de déterminer que la structure de la base de données respecte certaines contraintes de modélisation. Leur respect permet de garantir certaines propriétés du modèle relationnel.

## Structured Query Language SQL 

L’algèbre relationnel associé au modèle a permis la standardisation d’un langage de définition, de manipulation de données et de requêtes : Sequel ou SQL pour Structured Query Language SQL, créé en 1974, et normalisé depuis 1986 (*ISO/CEI 9075 - Technologies de l'information - Langages de base de données - SQL*).

Les instructions SQL couvrent quatre domaines :

- Langage de définition de données,
- Langage de manipulation de données,
- Langage de contrôle de données,
- Langage de contrôle des transactions.

---

## Langage de définition de la donnée

> Langage de définition de la donnée (LDD). Langage qui permet au concepteur du schéma physique ou à l’administrateur de la base de données de nommer les entités, les attributs et associations constituant la structure de la BD, ainsi que les contraintes d’intégrité et de sécurité associées (*Data Definition Language*).

## Langage de manipulation de données

> Langage de manipulation de données (LMD). Langage qui fournit un ensemble d’opérations élémentaires de manipulation de données telles que l’insertion, la modification, la recherche, l’extraction et la de données suppression de données contenues dans une base de données (*Data Manipulation*)

Gilles Roy. 2007. *Conception de bases de données avec UML*. Québec : Presses de l’Université du Québec.

???

> Langage de définition de la donnée (LDD). Langage qui permet au concepteur du schéma physique ou à l’administrateur de la base de données de nommer les entités, les attributs et associations constituant la structure de la BD, ainsi que les contraintes d’intégrité et de sécurité associées (*Data Definition Language*).

Langage de manipulation de données

> Langage de manipulation de données (LMD). Langage qui fournit un ensemble d’opérations élémentaires de manipulation de données telles que l’insertion, la modification, la recherche, l’extraction et la de données suppression de données contenues dans une base de données (*Data Manipulation*)

SQL définit notamment des instructions pour la manipulation du contenu de la base de données telles que SELECT, UPDATE, INSERT ou DELETE qui correspondent respectivement aux opérations de recherche, de modification, d’ajout et de suppression de données.

D’autres mots-clefs comme FROM, JOIN et GROUP BY permettent d’indiquer les opérations d’algèbre relationnelle à effectuer en vue d’obtenir le contenu à manipuler.

---

## Autres modèles de données

Bases de données orientées documents

Bases de données en Graphe et TripleStore

Bases de données tabulaires

???

Plusieurs implémentations possibles.

- Web dynamique et SGBDR
- Bases de données des grands musées

Langage de représentation, langage de requête (SQL)

### Autres SGBD, orientés document

- BaseX, eXist, Marklogic
- Apache Sarks ?
- CouchDB, MongoDB

### Triple store

- Jena
- Fuseki
- virtuoso
- stardog

---

## Modélisation

**Comme modèle abstrait, requiert un travail préalable de modélisation.** Ici on doit commencer par identifier des groupes d’objets de la réalité que l’on veut représenter et que l’on considère comme stable et homogène.

> Modèle de données : Un modèle est une représentation simplifiée d’une réalité. Un modèle de données de données est une représentation abstraite des données d’un système d’information. Cette représentation est généralement exprimée à l’aide d’un langage graphique appelé Formalisme (*Data model*).
>
> (Roy 2007)

Modélisation de classes. Chaque groupe possède ses caractéristiques propres. 

- Attributs de cette classe
- Relations entre ces classes

???

**Modèle conceptuel** qui découle de l’analyse des besoins.

> Modèle conceptuel de données : Un modèle conceptuel de données est une représentation des besoins en matière conceptuel de données pour un système d’information. Il met en évidence les entités, leurs de données attributs, les associations et contraintes entre ces entités pour un domaine donné. Cette représentation, de nature sémantique, ne comporte aucune indi­cation concernant la structure de mémorisation des données associées aux entités. Le modèle conceptuel est généralement représenté à l’aide du Formalisme entité­-association (*Conceptual model*).

**Le modèle physique** dérive du modèle logique ou du modèle conceptuel et décrit en pratique comment els données sont techniquement stockées dans la mase de données.

Pour définir un modèle de données, on utilise habituellement un formalisme. 

Formalisme

> Un ensemble de règles de représentation permettant de formuler un modèle graphiquement. Il comporte un certain nombre de concepts de base permettant d’exprimer un modèle. La représentation graphique des concepts dépend de la notation employée (*Formalism*).

---

## Formalisme Entités-Association (EA)

> **Entité** : Objet concret ou abstrait du monde réel au sujet duquel une organisation est susceptible de conserver des données (*Entity*).

> **Attribut** : Donnée élémentaire qui sert àà caractériser une propriéteé des entités et des associations dans un modèle conceptuel de données (*Attribute*).

> **Occurrence d’entité** : Élément particulier d’une entité type, identifiable de façon unique. (*Instance*)

???

Le *formalisme entité-association* (EA), initialement appelé entité-relation (*entity-relationship*) par son auteur P. Chen

---

## Formalisme Entités-Association (EA)

Rendre le modèle explicite en faisant appel au formalisme d’Entités-assocaition (*Entity-Relation ER*)

#### entités

*représentées par des rectangles*

un groupe d’objets du monde qui jouent un rôle important ;

#### attributs

*représentés par des petites bulles*

les caractéristiques d’un groupe d’objets ;

#### relations

*représentées par des lignes*

les liens entre les entités.

???

Le *formalisme entité-association* (EA), initialement appelé entité-relation (*entity-relationship*) par son auteur P. Chen

Rendre le modèle explicite en faisant appel au formalisme d’Entités-relations ER

- entités (représentées par des rectangles) : un groupe d’objets du monde qui jouent un rôle important ;
- attributs (représentés par des petites bulles) : les caractéristiques d’un groupe d’objets ;
- relations (représentées par des lignes) : les liens entre les entités.

---

### Formalisme entité-association (suite)

> **Association** : Lien sémantique qui existe entre deux entités ou plus. Elle représente souvent la mémoire d’un événement qui a permis d’établir un lien logique entre ces entités (*Relationship*).

>À ces trois éléments (entité, attribut, association), il faut ajouter une composante supplémentaire importante : **les cardinalités**. Ce concept permet de définir le nombre minimal et maximal d’individus qui participent à la relation entre deux entités. Généralement, on fait appel à trois possibilités : `0`, `1` ou `n`. Le `n` représente chaque nombre au dessus de 1.

???

Cardinalité ou Multiplicité : Contrainte inscrite à chaque extrémité d’une association binaire comportant (association un couple de valeurs (minimum−maximum) qui établit, pour chaque entité de binaire) l’association, les nombres minimum et maximum d’occurrences de l’autre entité qui peuvent lui être associées (*Multiplicity*).

**Les cardinalités permettent ainsi de veiller sur la cohérence des enregistrements et d’imposer des limites aux types de transactions qui peuvent être réalisées au sein de la base de données.**

- Ouvrage-Éditeur (1,1) : un ouvrage doit être publié chez un éditeur, et ne peut pas être publié par plusieurs éditeurs en même temps ;
- Éditeur-Ouvrage (1,n) : un éditeur doit avoir publié au moins un livre, mais peut en avoir édité plusieurs ; 
- Ouvrage-Emprunteur (0,1) : un ouvrage ne doit pas nécessairement être emprunté, et ne peut être emprunté que par une seule personne à la fois ;
- Emprunteur-Ouvrage (0,n) : une personne n’est pas obligée d’emprunter un livre, et peut en emprunter plusieurs en même temps.

Complexité qui permet d’assurer le contrôle et la consistance des informations. Possibilité de partager des entités en les liants.

**Possibilité de typage des informations** (dates, chaînes de caractère, etc.)

**Langages de requêtes**.

Notation Chen ER https://vertabelo.com/blog/chen-erd-notation/

Chen, Peter Pin-Shan. 1976. « The entity-relationship model&#x2014;toward a unified view of data ». *ACM Transactions on Database Systems* 1 (1) : 9‑36. https://doi.org/10.1145/320434.320440.

Exemple UML Unified modelling language : HADOC

**Logiciels**

Inconvénients : pas à la portée de chacun, données binaires, barrière sémantique. Problème d’exposition sur le web.

Pas de conservation de l’information initiale, oblige à discrétiser l’information. Pb pour les textes historiques et le traitement des sources.

Gère assez mal la hiérarchie.

---

![analogieSGBDR](imagesMSL/relationalModel.png)

---

![analogieSGBDR](imagesMSL/entite.png)

---

![analogieSGBDR](imagesMSL/relation.png)

---

![analogieSGBDR](imagesMSL/multiplicite.png)

---

![analogieSGBDR](imagesMSL/analogieSGBDR.png)

---

![Table_relationnel](imagesMSL/Table_relationnel.png)

---

![relation01](imagesMSL/relation01.gif)

---

![example-relational2](imagesMSL/example-relational2.png)

???

A data store that organizes data using the relational model is referred to as a relational database. Primary keys uniquely identify rows within a table. Foreign key fields are used in one table to refer to a row in another table by referencing the primary key of the other table. Foreign keys are used to maintain referential integrity, ensuring that the referenced rows are not altered or deleted while the referencing row depends on them.

Relational databases support various types of constraints that help to ensure data integrity:

- Unique constraints ensure that all values in a column are unique.
- Foreign key constraints enforce a link between the data in two tables. A foreign key references the primary key or another unique key from another table. A foreign key constraint enforces referential integrity, disallowing changes that cause invalid foreign key values.
- Check constraints, also known as entity integrity constraints, limit the values that can be stored within a single column, or in relationship to values in other columns of the same row.

https://docs.microsoft.com/en-us/azure/architecture/data-guide/relational-data/

La présence d’un identifiant marqué de la contrainte {Unique} pour une entité
représente une contrainte d’intégrité d’entité.

Règle d’identité

Toute entité présente dans un modèle conceptuel de données doit comporter
obligatoirement un identifiant. Chaque occurrence de l’entité doit posséder une
valeur pour cet attribut. La valeur de l’attribut identifiant devra être stable, c’est-à-dire
qu’au cours de la vie d’une occurrence de l’entité cette valeur ne pourra changer. De
plus deux occurrences de l’entité ne pourraient avoir la même valeur pour leur iden-
tifiant. La même valeur accordée plus d’une fois à un identifiant représente un
doublon. Les doublons sont inacceptables pour un identifiant.

Un autre type de contrainte doit être ajouté au modèle conceptuel dès
lors que les identifiants des entités associées sont établis. Il s’agit des contraintes
de multiplicité qui précisent à la fois que la participation d’une entité à l’asso-
ciation est obligatoire ou non, et le cas échéant, le nombre d’occurrences
d’une association auxquelles elle peut participer.

La figure 1-7 montre un modèle conceptuel maintenant complet avec
les deux contraintes de multiplicité placées de part et d’autre de l’association.
Toute association binaire comporte deux multiplicités car une association se
lit dans les deux directions avec des multiplicités qui peuvent être différentes.

Ces contraintes, appelées contraintes de domaine de l’attribut, vont
fixer le type de données de l’attribut et les valeurs admissibles de l’attribut.

Règle de description

Chaque attribut d’une entité présente dans le modèle conceptuel ne peut prendre
qu’une seule valeur à la fois pour son occurrence. Cette valeur doit provenir du
domaine décrit par les contraintes de domaine de l’attribut.

Règle de non redondance

Chaque attribut du modèle conceptuel est unique, il ne peut y apparaître plus d’une
fois à travers plusieurs entités du modèle.

---

Règles de gestion d’un système relationnel de base des données

- Unicité
- Garanties d’accès
- Traitement des valeurs nulles
- Catalogue lui-même relationnel
- Sous-langage de données
- Mise à jour des vues
- Insertion, mise à jour, et effacement de haut niveau
- Indépendance physique
- Indépendance logique
- Indépendance d’intégrité
- Indépendance de distribution
- Règle de non-subversion

???

> - Règle 1 
>
>   *Unicité* :
>
>   Toute l'information dans la base de données est représentée d'une et une seule manière, à savoir par des valeurs dans des champs de colonnes de tables.
>
> - Règle 2 
>
>   *Garantie d'accès* :
>
>   Toutes les données doivent être accessibles sans ambiguïté. Cette règle est essentiellement un ajustement de la condition fondamentale pour des clefs primaires. Elle indique que chaque valeur scalaire individuelle dans la base de données doit être logiquement accessible en indiquant le nom de la table contenante, le nom de la colonne contenante et la valeur principale primaire de la rangée contenante.
>
> - Règle 3 
>
>   *Traitement des valeurs nulles* :
>
>   Le système de gestion de bases de données doit permettre à chaque champ de demeurer nul (ou vide). Spécifiquement, il doit soutenir une représentation "d'information manquante et d'information inapplicable" qui est systématique, distincte de toutes les valeurs régulières (par exemple, "distincte de zéro ou tous autres nombres," dans le cas des valeurs numériques), et ce indépendamment du type de données. Cela implique également que de telles représentations doivent être gérées par le système de gestion de bases de données d'une manière systématique.
>
> - Règle 4 
>
>   *Catalogue lui-même relationnel* :
>
>   Le système doit supporter un catalogue en ligne, intégré, relationnel, accessible aux utilisateurs autorisés au moyen de leur langage d'interrogation régulier. Les utilisateurs doivent donc pouvoir accéder à la structure de la base de données (catalogue) employant le même langage d'interrogation qu'ils emploient pour accéder aux données de la base de données.
>
> - Règle 5 
>
>   *Sous-langage de données* :
>
>   Le système doit soutenir au moins un langage relationnel qui:a une syntaxe linéairepeut être employé interactivement et dans des programmes d'application,supporte des opérations de définition d'informations supplémentaires (incluant des définitions de vues), de manipulation de données (mise à jour aussi bien que la récupération), de contraintes de sécurité et d'intégrité, et des opérations de gestion de transaction (commencer, valider et annuler une transaction).
>
> - Règle 6 
>
>   *Mise à jour des vues* :
>
>   Toutes les vues pouvant théoriquement être mises à jour doivent pouvoir l'être par le système.
>
> - Règle 7 
>
>   *Insertion, mise à jour, et effacement de haut niveau* :
>
>   Le système doit supporter les opérations par lot d'insertion, de mise à jour et de suppression. Ceci signifie que des données peuvent être extraites d'une base de données relationnelle dans des ensembles constitués par des données issues de plusieurs tuples et/ou de multiples table. Cette règle explique que l'insertion, la mise à jour, et les opérations d'effacement devraient être supportées aussi bien pour des lots de tuples issues de plusieurs tables que juste pour un tuple unique issu d'une table unique.
>
> - Règle 8 
>
>   *Indépendance physique* :
>
>   Les modifications au niveau physique (comment les données sont stockées, si dans les rangées ou les listes liées, etc.) ne nécessitent pas un changement d'une application basée sur les structures.
>
> - Règle 9 
>
>   *Indépendance logique* :
>
>   Les changements au niveau logique (tables, colonnes, rangées, etc) ne doivent pas exiger un changement dans l'application basée sur les structures. L'indépendance de données logiques est plus difficile à atteindre que l'indépendance de données physiques.
>
> - Règle 10 
>
>   *Indépendance d'intégrité* :
>
>   Des contraintes d'intégrité doivent être indiquées séparément des programmes d'application et être stockées dans le catalogue. Il doit être possible de changer de telles contraintes au fur et à mesure sans affecter inutilement les applications existantes.
>
> - Règle 11 
>
>   *Indépendance de distribution* :
>
>   La distribution des parties de la base de données à de diverses localisations doit être invisible aux utilisateurs de la base de données. Les applications existantes doivent continuer à fonctionner avec succès :quand une version distribuée du système de gestion de bases de données est d'abord présentée ; etquand des données existantes sont redistribués dans le système.
>
> - Règle 12 
>
>   *Règle de non-subversion* :
>
>   Si le système fournit une interface avec langage de bas niveau, cette interface ne doit pas permettre de contourner le système (par exemple pour ajouter une contrainte relationnelle de sécurité ou d'intégrité) : ces contraintes doivent être exprimées dans le langage relationnel de haut niveau.

---

## Modèle physique

Clé primaire

> Dans les modèles de données *relationnels*, la *clé primaire* est un attribut dont le contenu est différent pour chaque enregistrement de la table, ce qui permet de retrouver un et un seul enregistrement

Clé étrangère

> Dans les modèles de données *relationnels*, une *clé étrangère* est un attribut qui contient une référence à une donnée connexe — dans les faits la valeur de la clé primaire de la donnée connexe.

intégrité référentielle

> Dans les modèles de données *relationnels*, il y a situation d’intégrité référentielle lorsque toutes les données référencées par les *clés étrangères* sont présentes dans la base de données.

cf. Wikipédia

---

## Unified Modeling Language (UML)

### Langages de modélisation

- langage artificiel destiné à exprimer de l’information, de la connaissance ou des systèmes
- destinés à faciliter la communication et la représentation formelle d’un domaine
- graphiques ou textuels

### Unified Modeling Language (UML)

http://www.uml.org

> A specification defining a graphical language for visualizing, specifying, constructing, and documenting the artifacts of distributed object systems.
>
> https://www.omg.org/spec/UML

???

l’élaboration d’un modèle conceptuel de données 

> Un modèle conceptuel de données est une représentation des besoins en matière conceptuel de données pour un système d’information. Il met en évidence les entités, leurs de données attributs, les associations et contraintes entre ces entités pour un domaine donné. Cette représentation, de nature sémantique, ne comporte aucune indication concernant la structure de mémorisation des données associées aux entités. Le modèle conceptuel est généralement représenté à l’aide du Formalisme entité-association (*Conceptual model*). 
>
> Un ensemble de règles de représentation permettant de formuler un modèle graphiquement. Il comporte un certain nombre de concepts de base permettant d’exprimer un modèle. La représentation graphique des concepts dépend de la Notation employée (*Formalism*).
>
> Roy 2007

### Langages de modélisation

Un langage de modélisation est un langage artificiel destiné à exprimer l’information de la connaissance ou des systèmes. Ces langages peuvent être graphiques ou textuels.

Ils sont souvent destinés à faciliter la communication entre les acteurs ou à faciliter la représentation formelle d’un domaine.

- Diagramme entité relation
- Merise
- Unified Modeling Language (UML)

Le formalisme entité-association présente l’avantage d’une certaine simplicité pour l’apprentissage de la modélisation conceptuelle. Il existe toutefois d’autres méthodes et d’autres formalismes pour rendre compte d’un modèle conceptuel. Depuis plusieurs années, le langage unifié de modélisation UML s’est très très largement imposé dans la description des systèmes informatiques. Il peut donc être utile de pouvoir lire les diagrammes générés dans ce formalisme.

### UML

> Le Langage de Modélisation Unifié, de l’anglais Unified Modeling Language (**UML**), est un langage de modélisation graphique à base de pictogrammes conçu pour fournir une méthode normalisée pour visualiser la conception d’un système. Il est couramment utilisé en développement logiciel et en conception orientée objet.
>
> Wikipédia

>The objective of UML is to provide system architects, software engineers, and software developers with tools for analysis, design, and implementation of software-based systems as well as for modeling business and similar processes.
>
>https://www.omg.org/spec/UML

UML peut être utilisé pour produire différents types de diagrammes

- **diagrammes de structure** comme des diagrammes de classes, d’objets de composants, de structure composite, de package ou de déploiement
- **diagrammes de comportements**, cas, activité, état
- **diagrammes d’interactions**, communication, temporalités, interactions

Dans le cadre du programme d’harmonisation des données culturelles engagé par le ministère de la Culture et des communications en France, UML a été utilisé pour produire une modélisation issue de la modélisation orientée-objet. 

Modélisation issue de la modélisation orientée-objet (Booch, OMT, and OOSE). Langage destiné à l’interopérabilité, surtout destiné à faciliter l’échange d’information modélisées entre outils et acteurs, lorsqu’un accord doit être trouvé sur la sémantique ou la syntaxe.

> Le formalisme qu'il propose en fait un support de communication performant, qui facilite la représentation et la compréhension des modèles par les différents acteurs : la notation graphique permet de les exprimer visuellement en limitant les ambiguïtés et les risques d'incompréhension. Le niveau d'abstraction qu'il supporte permet de mieux contrôler la complexité dans l'expression et l'élaboration des solutions. Enfin, son indépendance par rapport aux langages de programmation, aux domaines d'application et aux processus en fait un langage universel.
>
> HADOC

Le langage de modélisation contient

- une définition formelle d’un métamodèle qui spécifie une syntaxe abstraite et définit un ensemble de concepts de modélisation, leurs attributs et leurs relations et les règles qui permettent de combiner ces concepts pour construire des modèles UML partiels ou complets
- une explication détaillée de la sémantique de chaque concept d’UML. Celle-ci est définie indépendamment de la technologie
- Une spécification d’une notation lisible par l’homme des concepts de modélisation et des règles pour les combiner dans différents aspects de la modélisation

Notion de conformance

Sémantique de UML

> Un modèle est toujours un modèle de quelque chose. Ce qui est modélisé peut généralement être considérés comme un *système* au sein d’un *domaine* du discours. Le modèle établi alors des déclarations d’intérêt au sujet de ce système, en s’abstrayant de tous les détails du système qui peuvent être décrit, d’un certain point de vue et pour un certain but. Pour un système existant, le modèle peut représenter une analyse des propriétés et du comportement du système. Pour un système planifié, le modèle peut représenter une spécification de la manière dont le système doit être construit et se comporter.
>
> https://www.omg.org/spec/UML 6.3.1 traduction

Un modèle UML peut consister en trois catégories génériques d’éléments de modèle.

- *Classifiers*. qui décrivent un ensemble d’objets. Un *objet* est un individu avec un *état* (state) et des *relations* (relationships) avec d’autres objets. L’état d’un objet identifie les valeurs des *propriétés* (properties) de cet objet.
- *Events*. Un *événement* (event) décrit un ensemble d’occurences possibles. Une *occurence* est quelque chose qui arrive et qui a ds conséquences sur le système.
- *Behaviors*. Un comportement (behavior) décrit un ensemble d’exécutions possibles. Une *exécution* est la réalisation d’un ensemble d’actions (potentiellement sur une période donnée) qui peut générer et répondre à des occurrences d’événement, y compris accéder et changer l’état des objets.

UML ne contient pas les objets, les occurrences et les exécutions car ces individus font partie du domaine modélisé et pas du contenu des modèles. UML ne dispose donc pas de construction de modélisation pour modéliser directement les individus, la spécification des instances, des occurrences ou des exécutions.

La syntaxe d’UML indique comment des modèles doivent être construits représentés et échangés. La spécification définit la syntaxe d’UML à la fois abstraitement et concrètement.

cf. figure 6.1 Semantic Areas of UML

---

## Structure commune

**Les concepts de base d’*Élement* et de *Relation* fournissent la base de tous les autres concepts de modélisation en UML.**

- Un **Élément** est un constituant d’un modèle, ses Descendants fournissent les sémantiques appropriées au concept qu’ils représentent.

  Un Élément a la capacité inhérente d’être propriétaire d’autres Éléments (ownedElement). Chaque Élément peut posséder des Commentaires (ownedComments) qui représentent de l’information utile pour le lecteur du modèle.

- Une **Relation** spécifie des types de relations entre d’autres Éléments. Les Descendants de la relation fournissent les sémantiques appropriées au concept qu’ils représentent.
  Une relation dirigée (DirectedRelationship) représente une Relation entre une collection d’éléments source (source) et d’éléments cibles (target). Une relation dirigée est dite dirigée des éléments source vers les éléments cibles.

???

Structure commune

Concepts de modélisation de base sous-jacent à toutes les modélisation structurelles en UML.

**Les concepts de base d’*Element* et de *Relation* fournissent la base de tous les autres concepts de modélisation en UML.**

Un **Élément** (Element) est un constituant d’un modèle, ses Descendants fournissent les sémantiques appropriées au concept qu’ils représentent.

Un Élément a la capacité inhérente d’être propriétaire d’autres Éléments (ownedElement). Chaque Élément peut posséder des Commentaires (ownedComments) qui représentent de l’information utile pour le lecteur du modèle.

Une **Relation** (Relationship) est un Élément qui spécifie des types de relations entre d’autres Eléments. Les Descendants de la relation fournissent les sémantiques appropriées au concept qu’ils représentent.

Une relation dirigée (DirectedRelationship) représente une Relation entre une collection d’éléments source (source) et d’éléments cibles (target). Une relation dirigée est dite dirigée des éléments source vers les éléments cibles.

Il n’y a pas de notation générale pour les Éléments, les Relations et les Relations dirigées. Les descendants de ces classes définissent leur propre notation.

- les relations sont généralement des lignes entre les relatedElements. 
- Pour les DirectedRelationships ces lignes sont dirigées de la source vers la cible.
- Un Commentaire (Comment) apparaît sous la forme d’un rectangle dont l’angle droit est plié (note symbol), ce rectangle contient le corps du Commentaire. La connexion avec les annotatedElement est présentée avec une ligne pointillée.

Les Templates sont des Élément de modèle qui sont paramétrisés par d’autres Éléments du model.

@todo continuer

---

### Concepts de base des diagrammes de classe UML

> Une **Classe** est la description abstraite d'un ensemble d'« objets » du monde réel (choses physiques ou concepts abstraits) qui partagent les mêmes propriétés et les mêmes comportements.
>
> Exemples : Acteur, Evenement, Dimension, Localisation ...
>
> Les objets du monde réel qui peuvent être décrits au moyen de la classe constituent les instances de cette classe. 
>
> Exemple : Victor Hugo est une instance de la Classe Acteur 
>
> Le nom des classes est exprimé en casse de titre anglais (majuscule initiale pour chaque élément signifiant), avec espaces et sans caractères accentués.
>
> Exemples : Bien Culturel, Coordonnees Projetees
>
> Hadoc

???

> Le formalisme entité-association fait appel à trois concepts premiers, soit entité, association, et attribut qui sont relatifs à la sémantique des données et trois concepts accessoires, identifiant occurrence et multiplicité, pour l’expression des contraintes d’intégrité des données du modèle.

Une **Classe** est la description abstraite d'un ensemble d'« objets » du monde réel (choses physiques ou concepts abstraits) qui partagent les mêmes propriétés et les mêmes comportements.

Les objets du monde réel qui peuvent être décrits au moyen de la classe constituent les instances de cette classe. 

Le nom des classes est exprimé en casse de titre anglais (majuscule initiale pour chaque élément signifiant), avec espaces et sans caractères accentués.

On peut mettre en parallèle la définition des classes UML et la définition des classes d'une ontologie, telle qu'elle est exprimée par exemple dans la norme ISO 21127, ontologie pour les informations concernant le patrimoine culturel : « catégorie d'entités qui partagent une ou plusieurs propriétés communes ». 

9 Classification (p. 99)

> La classification est une technique importante pour l’organisation. Cette clause spécifie les concepts en rapport à la classification. Le concept de base est le Classifier, une métaclasse abstraite dont les sous-classes concrètes sont utilisées pour classifier différents genres de valeurs.
> L’autre métaclasse de cette clause et la clause qui représente les constituants des Classifiers, et modélise comment les Classifiers sont instanciés en utilisant InstanceSpecifications, et d’autres relations entre ces concepts.
>
> https://www.omg.org/spec/UML 9 traduction

Un Classifier représente une classification d’instances d’après leurs Features. Les Classifiers sont organisés en hiérarchies par Généralisations (Generalizations). Les ElementsRedefinissables (RedefinableElements) peuvent être redéfinis dans le contexte de hiérarchies de Généralisation.

Les Généralisations (Generalizations) définissent les relations de généralisation/spécialisation entre les Classes. Chaque Généralisation rest relative à un Classifier spécifique ou à un Classifier plus général. 

La Classe est une métaclasse abstraite. Leur notation par défaut est un rectangle à bordure qui contient le nom de la Classe et est compartimenté par des lignes horizontales. Les noms des classes débutent par une majuscule.

Le compartiment des attributs continent la notation des Propriétés qui sont atteintes par l’intermédiaire de la propriété attribuée. Il est obligatoire et apparaît en premier. Compartiment des opérations obligatoire, réceptions id.

**Le diagramme de classe est l’un des types de diagrammes les plus important en UML.**

Les classes

Une classe est un concept absratit 

Les instances de classes

---

### Attribut

> Un **Attribut** est une propriété d'une Classe, qui possède une valeur courante pour chaque objet. Chaque Attribut possède un Type. 
>
> *Exemple : La forme autorisée d'un nom propre de personne est un attribut de la classe Acteur ayant pour libellé formeAutorisee. Il prend la valeur courante « Lépicié, Nicolas-Bernard* 
>
> Michel (1735-1784) » pour le peintre Nicolas-Bernard Lépicié, qui est une instance de la classe Acteur. 
>
> Le nom des attributs est exprimé en respectant la casse dite « lowerCamelCase », sans espaces ni carac- tères accentués. 
>
> *Exemples : categorieTechnique, dateFinValidite, photoIdentite* 

---

### Association

> Une **Association** est une relation statique entre des Classes : elle décrit la relation sémantique existant entre celles-ci. 
>
> *Exemple : La classe Bien Culturel est reliée à la classe Evenement par l'association aEteAffectePar.* 
>
> Les associations sont bidirectionnelles : un Bien culturel est affecté par un Événement. Un Événement affecte un Bien culturel. 

???

Une **Association** est une relation statique entre des Classes : elle décrit la relation sémantique existant entre celles-ci. 

*Exemple : La classe Bien Culturel est reliée à la classe Evenement par l'association aEteAffectePar.* 

On peut mettre en parallèle la définition des associations UML et la définition des propriétés d'une ontologie, telle qu'elle est exprimée par exemple dans la norme ISO 21127, ontologie pour les informations relatives au patrimoine culturel : « caractéristique déterminante qui sert à définir une relation d'un type spécifique entre deux classes ». 

Les associations sont bidirectionnelles : un Bien culturel est affecté par un Événement. Un Événement affecte un Bien culturel. 

---

### Rôle 

> Le **rôle** est un nom donné à une extrémité de l’Association. 
>
> Exemples : L’**Association** qui relie un `Acteur` à un `Événement` a pour rôle « aParticipeA » ; L’Association qui relie un `Bien culturel` à une `Localisation` a pour rôle *aPourLocalisation*.
>  Les Associations étant bidirectionnelles, le rôle est fonction du sens de lecture de la relation. 
>
> Exemple : Un événement `aEuPourCadre` un lieu ; un lieu `aEteTemoinDe` un événement. 

---

### Agrégation 

> L’**Agrégation** est un type particulier d’association entre deux Classes. Elle signifie qu’une instance de la classe source (ou « agrégat ») possède une ou plusieurs instances (ou « composants ») de la classe cible. Par exemple, un Bien culturel possède une ou plusieurs Appellations. 

![uml01](imagesMSL/uml01.png)

???

@todo schema

L’Agrégation est un type particulier d’association entre deux Classes. Elle signifie qu'une instance de la classe source (ou « agrégat ») possède une ou plusieurs instances (ou « composants ») de la classe cible. Par exemple, un Bien culturel possède une ou plusieurs Appellations. 

---

### Composition 

> La Composition est une association forte entre l’agrégat et ses composants. Si l’agrégat est supprimé, ses composants le sont aussi. Si l’agrégat est dupliqué, ses composants le sont également. 
>
> Par exemple, un Bien culturel possède en propre des dimensions, qui n’ont de sens que par rapport à ce Bien culturel. Si une instance de Bien culturel disparaît (par exemple, si l’information relative à un Bien culturel disparaît de la base de données), les informations relatives à ses dimensions disparaissent avec elle. 

![uml01](imagesMSL/uml02.png)

???

@todo schema

---

### Héritage 

> L’Association de généralisation/spécialisation, ou « héritage », permet de regrouper au sein d’une classe générale (dite « classe de généralisation » ou « sur-classe » ou « super-classe ») les propriétés communes de classes spécifiques (dites « classes de spécialisation » ou « sous-classes »), qui lui sont associées par une relation de type « estUn ». 
>

![uml01](imagesMSL/uml03.png)

???

Par exemple, la classe Appellation permet de regrouper les attributs communs à chacune des classes de spécialisation que sont les classes Appellation Acteur et Appellation BC. 

Chacune des sous-classes hérite des propriétés de la super-classe : par exemple, la classe Appellation Acteur et la classe Appellation BC héritent de la super-classe Appellation un attribut libelle, un attribut langue ou encore un attribut dateAttestation 

@todo schema

---

### Classe d’association 

> La Classe d’association est un type particulier de Classe permettant d’apporter des informations sur l’asso- ciation existant entre deux classes. 
>

![uml01](imagesMSL/uml04.png)

???

Par exemple, on peut relier un Acteur à un Événement par une association ayant le rôle « aParti- cipeA ». Si l'on souhaite préciser que cet Acteur a participé à cet Événement en tant qu'organisateur, le rôle « organisateur » n'est une propriété intrinsèque ni de l'Acteur, ni de l’Événement, mais bien une propriété de l'Association qui relie l'Acteur et l’Événement. C'est la classe d'association qui portera cette information. 

@todo schema

>Dans cet exemple, il est possible de décrire plus précisément l'association qui unit l'Acteur à l'Événement
>au moyen d'attributs tels que fonction, justificationAttribution ,
>etendueIntervention etc. portés par la Classe d'association.

---

### Classe d'énumération 

> La Classe d'énumération est un type particulier de Classe présentant un ensemble fini des valeurs que peut recevoir un Attribut. 
>
> Par exemple, l'attribut calendrier de la classe Laps de Temps peut prendre cinq valeurs diffé- rentes rassemblées dans la Classe d'énumération TypeCalendrier. 
>
> Dans l'exemple suivant, une des valeurs possibles portées par la Classe d'énumération, « Calendrier grégorien », est définie comme la valeur par défaut : 
>
> calendrier:TypeCalendrier[1] = Calendrier grégorien

???

@todo schema

---

### Multiplicité 

> La multiplicité s'applique aux Associations entre les Classes ainsi qu'aux Attributs d'une Classe. 
>
> Appliquée aux Associations, elle permet de préciser le nombre d'associations possibles entre les instances des Classes reliées. La multiplicité est donc indiquée pour chaque extrémité de l'Association. 
>
> Exemple : un Bien culturel peut avoir plusieurs Identifiants, mais un Identifiant correspondra à un seul Bien culturel. 

![uml01](imagesMSL/uml05.png)

???

La multiplicité s'applique aux Associations entre les Classes ainsi qu'aux Attributs d'une Classe. 

Appliquée aux Associations, elle permet de préciser le nombre d'associations possibles entre les instances des Classes reliées. La multiplicité est donc indiquée pour chaque extrémité de l'Association. 

Exemple : un Bien culturel peut avoir plusieurs Identifiants, mais un Identifiant correspondra à un seul Bien culturel. 

---

## Multiplicité

Les différents cas possibles sont les suivants :

- **1** Il existe obligatoirement une et une seule instance de la classe cible. 
- **1..*** Il existe obligatoirement au moins une instance de la classe cible.
- **0..1** Il ne peut exister qu'une seule instance de la classe cible, mais elle est facultative.
- ***** Il peut exister n'importe quel nombre d'instances de la classe cible, et elle est facultative. 

???

Les différents cas possibles sont les suivants :

- **1** Il existe obligatoirement une et une seule instance de la classe cible. 
- **1..*** Il existe obligatoirement au moins une instance de la classe cible.
- **0..1** Il ne peut exister qu'une seule instance de la classe cible, mais elle est facultative.
- ***** Il peut exister n'importe quel nombre d'instances de la classe cible, et elle est facultative. 

Dans certains cas, on peut vouloir préciser le nombre exact d'instances de la classe cible attendues. Par exemple, un Laps de Temps est obligatoirement défini par deux Dates, la date de début et la date de fin. Cette information s'exprime de la façon suivante : 

@todo schema

> Dans certains cas, on peut vouloir préciser le nombre exact d'instances de la classe cible attendues. Par exemple, un Laps de Temps est obligatoirement défini par deux Dates, la date de début et la date de fin. Cette information s'exprime de la façon suivante : 
>
> Appliquée aux Attributs, la multiplicité permet de préciser si l'Attribut est facultatif ou obligatoire, et s'il peut être répété. 
>
> Exemple : un Bien culturel a obligatoirement un identifiant unique attribué par le ministère (1), il a au moins une dénomination mais peut en avoir plusieurs (1 à n), il est rattaché de manière facultative à une ou plusieurs catégories techniques (0, 1 ou n), il peut avoir une seule description sommaire, mais elle est facultative (0 ou 1). 
>
> Cette information s'exprime de la façon suivante : 
>
> identifiantMCC : Identifiant[1] denomination : ThesaurusConcept [1..*] categorieTechnique : ThesaurusConcept [*] 
>
> descriptionSommaire : NoteDescriptive [0..1] 
>
> Les différents cas possibles sont les suivants :
>  1 L'Attribut est obligatoire et non répétable (une seule occurrence). 
>
> 1..* L'Attribut est obligatoire et répétable (une ou plusieurs occurrences). 0..1 L'Attribut est optionnel et non répétable (zéro ou une occurrence).
>  \* L'Attribut est optionnel et répétable (zéro, une ou plusieurs occurrences). 
>
> Les Multiplicités correspondent soit à des évidences du monde réel (la définition d'un laps de temps nécessite l'expression d'une date de début et d'une date de fin), soit à des règles métier (un Bien culturel immobilier doit avoir au moins une information de localisation). Ces règles métier peuvent varier d'un domaine métier à un autre : par exemple, préciser les dimensions d'un Bien culturel peut avoir un carac- tère obligatoire dans le domaine Musées, et être considéré comme facultatif dans le domaine Architecture, voire non pertinent si l'on parle de patrimoine immatériel, tel un rituel ou une pratique. 
>
> Les Multiplicités portées par le modèle restent en général peu contraignantes. Les contraintes fortes (caractère obligatoire et/ou unique d'un Attribut ou d'une instance de Classe) ne sont mentionnées que pour garantir la présence du minimum d'informations nécessaires à l'identification non équivoque d'un Bien culturel ou d'un Acteur. En revanche, chaque application mettant en œuvre le modèle pourra ajouter des contraintes supplémentaires pour tenir compte des besoins métier et du contexte local. 

https://laurent-audibert.developpez.com/Cours-UML/?page=diagramme-classes

    Une association relie deux - ou plus - classes, sans induire de rôle particulier pour une classe; l'association se lie indistinctement dans les deux sens. 
    L'agrégation et la composition vont modéliser une situation où l'une des classe joue un rôle particulier, l'association n'est plus symétrique.


@todo exemple HADOC

@todo exemple Technès

---

### Notion de .red[modèle de données]

modèles documentaires

dictionnaire de données

standards de données et validation

### Notion de .red[champs] et de .red[valeurs]

Notion de contrôle syntaxique

Utilisation de vocabulaires et contrôle terminologique

### .red[Standardisation] et normalisation

### Fonctionnalités

- Stockage
- Requêtes
- Recherches plein-texte

---

## Champs et Structure de données

(*data fields*, *data structure*)

Les **champs de données** désignent les unités d’information, parfois désigné comme éléments ou catégories qui sont organisés dans un entregistrement sous la forme d’une structure de données.

- **Exemple :** 

  *Categories for the Description of Works of Art (CDWA)*

  <http://www.getty.edu/research/publications/electronic_publications/cdwa/introduction.html>

---

## Contenus et valeurs

(*data content*, *values*)

Les contenus ou et les valeurs sont les informations stockées dans les champs. Les standards de contenu sont les règles destinées à guider le renseignement de certains champs. Il peut s’agir de vocabulaires contrôlés, ou de  fichier d’autorité, ou encore de règles syntaxes qui fournissent des termes prédéfinis ou des conventions pour peupler les champs.

- **Exemple :** 

  *Cataloging Cultural Objects: A Guide to Describing Cultural Works and Their Images (CCO)*
  <http://cco.vrafoundation.org/>

---

## Exemples MySQL

???

```bash
mysql -u root -p
```



```sql
SHOW DATABASES;
```

```sql
USE mysql -u root -p
```

```sql
GRANT ALL PRIVILEGES ON *.* TO 'username'@'localhost' IDENTIFIED BY 'password';
```



```sql
CREATE DATABASE artistes;
```

```
USE artistes;
```

```sql
CREATE TABLE artiste;
```

```
DROP TABLE artiste;
```

```sql
CREATE TABLE example ( id smallint unsigned not null auto_increment, name varchar(20) not null, constraint pk_example primary key (id) );
INSERT INTO example ( id, name ) VALUES ( null, 'Sample data' );
```

```sql
SELECT user FROM mysql.user GROUP BY user;
```

```sql
CREATE TABLE artistes (
id INT(10) NOT NULL auto_increment,
nom VARCHAR(50) NOT NULL,
prenom VARCHAR(50) NOT NULL,
dateNaissance DATE,
PRIMARY KEY (id)
);
```

```sql
DESCRIBE artistes;
```

```sql
INSERT INTO artistes (id, nom, prenom, date_naissance) 
VALUES (1, 'Levêque', 'Claude', '1953-02-27');
```

```sql
SELECT * FROM artistes;
```

```sql
CREATE TABLE oeuvres (
idOeuvre INT(10) NOT NULL auto_increment,
titre VARCHAR(50) NOT NULL,
dateCreation DATE,
idCreateur INT(10),
PRIMARY KEY (idOeuvre),
FOREIGN KEY (idCreateur) REFERENCES artistes(id)
);
```

```sql
INSERT INTO artistes (id, nom, prenom, date_naissance) 
VALUES (2, 'Hantaï', 'Simon', '1922-12-07');
```

```sql
INSERT INTO oeuvres (idOeuvre, tite, dateCreation, idCreateur) 
VALUES (1, 'Paradiso', '2018-01-01', '1')
VALUES (2, 'Saturnales', '2019-01-01', '1')
VALUES (3, 'Aube bleue', '2018-01-01', '1')
VALUES (4, 'Tabula', '1980-01-01', '2')
;
```

```sql
Select nom, dateNaissance From artistes;
```

```sql
SELECT nom FROM artistes WHERE date='Air France';
```

---

## SQLite

https://www.sqlite.org

- librairie développée dans le langage C
- libre et ouvert
- auto-contenu
- utilisation de SQL

???

[SQLite](https://www.sqlite.org) est un moteur de base de données relationnelles léger, libre et ouvert conçu dans les années 2000 par Richard Hipp. Comme le « Lite » de son nom le suggère, il s’agit d’un logiciel de base de données relationnelles facile d’utilisation en termes de configuration, d’administration de bases de données. 

L’une des caractéristiques principales du logiciel qui lui vaut son succès, consiste dans le fait que les données sont auto-contenues dans un simple fichier qui peut être copié d’un ordinateur à l’autre pour la sauvegarde ou le partage. Cela facilite beaucoup la maintenance et constitue un format stable multiplateforme (engagement de rétro-compatibilité jusqu’en 2050). Par ailleurs, le logiciel ne nécessite pas de serveur pour fonctionner.

Comme la pluspart des Systèmes de gestion de base de données et à l’instar d’autres solutions libres et ouvertes comme MySQL ou PostgreSQL, le logiciel repose sur l’utilisation de SQL, un langage standardisé de manipulation et de mise à jour de données.

Caractéristiques

- transactions atomiques, consistantes, isolées et durables (ACID)
- pas de configuration
- complètement compatible avec SQL
- fichiers auto-contenus
- multiplateforme
- domaine public

Utilisation possible pour toute sorte de type d’applications :

- bases de données pour l’internet des objets
- formats d’applications
- site web
- etc.

---

## Syntaxe SQL

https://www.sqlite.org/lang.html

### Installation 

https://www.sqlite.org/download.html

### Exécuter SQLite

```shell
sqlite3
```

```shell
SQLite version 3.32.3 2020-06-18 14:16:19
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
```

???

- invite de ligne de commande.
- prompteur

---

 `.help` pour l’aide

`.databases`        List names and files of attached databases

`.tables` ?TABLE?     List names of tables matching LIKE pattern TABLE

`.quit`          Exit this program

Pour terminer une déclaration, tapper `;` suivi de `Enter` (dans un continuation prompt : `...>`)

---

## Environnement de développement intégré (IDE)

Plusieurs logiciels permettent de disposer d’une interface graphique pour travailler avec SQLite

https://sqlitestudio.pl

https://sqlitebrowser.org

https://dbeaver.io

---

Lancer SQLite3

```bash
sqlite3
```

Obtenir de l’aide

```sqlite
.help
```

Quitter sqlite

```sqlite
.exit
```

---

background-image: url(imagesMSL/sqlite-sample-database-diagram-color.jpeg)

https://www.sqlitetutorial.net

---

Explorer une base de données existante

```shell
sqlite3 path/to/chinook.db
```

```sqlite
.databases
```

```sqlite
.tables
```

```shell
albums          employees       invoices        playlists
artists         genres          media_types     tracks
customers       invoice_items   playlist_track
```

---

Ouvrir une session en créant une base de données qui n’existe pas encore

```sqlite
sqlite3 path/to/dbName.db
```

Ouvrir une base de données

```sqlite
.open path/to/db
```

Lister les bdd

```sqlite
.databases
```

---

Montrer les tables

```sqlite
.tables
```

Montrer la structure d’une table

```sqlite
.schema albums
```

Montrer toute la structure de données

```sqlite
.fullschema
```

---

Créer une nouvelle base de données dans le contexte

```sqlite
ATTACH DATABASE "path/to/dbName.db" AS dbName;
```

---

## Requêtes

`SELECT` clause la plus souvent emloyée dans les déclarations SQL pour requêter des données

```sqlite
SELECT 1 + 1;
```

```sqlite
.schema tracks
```

```sqlite
SELECT * FROM tracks;
```

```sqlite
SELECT trackid, name, composer, unitprice
FROM tracks;
```

???

La clause `SELECT`prend le nom d’un champ, ou une liste de champs séparés par des virgules, et est suivie du mot-clef `FROM`qui identifie la table requêtée. Le point-virgule termine la ligne.

L’astérix permet de retrouver les données de tous les champs. Ce n’est pas une solution recommandée en production.

---

## Clauses SQL

- `ORDER BY` ordonne l’ensemble de résultats
- `DISTINCT` requête des lignes uniques dans la table
- `WHERE` filtre les lignes dans l’ensemble de résultats
- `LIMIT` et `OFFSET` contraignent le nombre de lignes retournées
- `INNER JOIN` ou `LEFT JOIN` requête les données de plusieurs tables en utilisant des jointures
- `GROUP BY` groupes les lignes et applique une fonction d’agrégation pour chaque groupe
- `HAVING` filtre les groupes

---

## Exemple de requête SQL complexe

```sqlite
SELECT DISTINCT column_list
FROM table_list
  JOIN table ON join_condition
WHERE row_filter
ORDER BY column
LIMIT count OFFSET offset
GROUP BY column
HAVING group_filter;
```

---

## Structure d’une requête avec la clause `ORDER BY`

```sqlite
SELECT
   select_list
FROM
   table
ORDER BY
    column_1 ASC,
    column_2 DESC;
```

???

La clause `ORDER BY` vient après la clause `FROM`, elle permet de trier l’ensemble de résultats dans l’ordre ascendant ou descendant. Le mot-clef `ASC` signifie ascendant, `DES` descendant. L’ordre par défaut est l’ordre ascendant.

---

## Exemple d’une requête avec la clause `ORDER BY`

```sqlite
SELECT
	name,
	milliseconds, 
  albumid
FROM
	tracks;
```

```sqlite
SELECT
	name,
	milliseconds, 
	albumid
FROM
	tracks
ORDER BY
	albumid ASC;
```

---

## Exemple de requête avec la clause `ORDER BY`

```sqlite
SELECT 
    TrackId, 
    Name, 
    Composer 
FROM 
   tracks
ORDER BY 
   Composer;
```

---

## Filtrer les données

- [Select Distinct](https://www.sqlitetutorial.net/sqlite-select-distinct) – query unique rows from a table using the `DISTINCT` clause.
- [Where](https://www.sqlitetutorial.net/sqlite-where/) – filter rows of a result set using various conditions.
- [Limit ](https://www.sqlitetutorial.net/sqlite-limit/)– constrain the number of rows returned by a query and how to get only the necessary data from a table.
- [Between](https://www.sqlitetutorial.net/sqlite-between/) – test whether a value is in a range of values.
- [In](https://www.sqlitetutorial.net/sqlite-in/) – check if a value matches any value in a list of values or subquery.
- [Like](https://www.sqlitetutorial.net/sqlite-like/) – query data based on pattern matching using wildcard characters: percent sign (`%`) and underscore (`_`).
- [Glob](https://www.sqlitetutorial.net/sqlite-glob/) – determine whether a string matches a specific UNIX-pattern.
- [IS NULL](https://www.sqlitetutorial.net/sqlite-is-null/) – check if a value is null or not.

---

## Exemple de clause `SELECT DISTINCT`

```sqlite
SELECT city
FROM customers
ORDER BY city;
```

```sqlite
SELECT DISTINCT city
FROM customers
ORDER BY city;
```

---

## Exemple de clause `WHERE`

```sqlite
SELECT
   name,
   milliseconds,
   bytes,
   albumid
FROM
   tracks
WHERE
   albumid = 1;
```

???

`WHERE` pour ajouter une condition

Utilisation d’opérateurs.

```sqlite
SELECT
   name,
   milliseconds,
   bytes,
   albumid
FROM
   tracks
WHERE
   albumid = 1
   AND milliseconds > 250000;
```

```sqlite
SELECT
	name,
	albumid,
	composer
FROM
	tracks
WHERE
	composer LIKE '%Smith%'
ORDER BY
	albumid;
```

```sqlite
SELECT
	name,
	albumid,
	mediatypeid
FROM
	tracks
WHERE
	mediatypeid IN (2, 3);
```



---

## Jointures

Les jointures en SQL permettent d’associer plusieurs tables dans une même requête. Elles permettent ainsi d’obtenir des résultats qui combinent les données issues de plusieurs tables.

- [SQLite join](https://www.sqlitetutorial.net/sqlite-join/) – learn the overview of joins including inner join, left join, and cross join.
- [Inner Join](https://www.sqlitetutorial.net/sqlite-inner-join/) – query data from multiple tables using the inner join clause.
- [Left Join](https://www.sqlitetutorial.net/sqlite-left-join/) – combine data from multiple tables using the left join clause.
- [Cross Join](https://www.sqlitetutorial.net/sqlite-cross-join/) – show you how to use the cross join clause to produce a cartesian product of result sets of the tables involved in the join.
- [Self Join](https://www.sqlitetutorial.net/sqlite-self-join/) – join a table to itself to create a result set that joins rows with other rows within the same table.
- [Full Outer Join](https://www.sqlitetutorial.net/sqlite-full-outer-join/) – show you how to emulate the full outer join in the SQLite using left join and union clauses.

???

Le plus souvent les jointures consistent à associer les lignes de deux tables en fonction de l’égalité des valeurs des colonnes d’une première table avec celle d’une seconde table. 

Il existe plusieurs méthodes pour associer deux tables ensembles.

- Une jointure interne (*inner join*) retourne une valeur quand une condition est vraie dans les deux tables. C’est le type de jointure le plus courramment utilisé.
- Une jointure croisée (*cross join*) permet de réaliser le produit cartésien de deux tables. Elle permet de joindre chaque ligne d‘une tabel avec chaque ligne d’une seconde table. Elle ramène souvent un nombre de résultat élevé.
- Une jointure externe (*left join*) retourne tous les enregistrements de la table de gauche, même si une condition n’est pas vérifiée dans une autre table.
- ...

Wickham, Hadley, Mine Çetinkaya-Rundel, et Garrett Grolemund. « 20. Joins ». In *R for Data Science. Import, Tidy, Transform, Visualize, and Model Data*, 2e éd. O’Reilly Media, 2023. https://r4ds.hadley.nz/.

Adams, Frank. « Mastering SQL Query Optimization: Understanding the 7 Steps of Execution ». *Medium* (blog), 4 juillet 2023. https://medium.com/@FrankAdams7/mastering-sql-query-optimization-understanding-the-7-steps-of-execution-ead06774e5ed.

---

background-image: url(imagesMSL/sqlJoin.png)

---

background-image: url(imagesMSL/sqlJoins.png)

.footnote[https://dataschool.com/how-to-teach-people-sql/sql-join-types-explained-visually/]

---

background-image: url(imagesMSL/sqlJoinsViz.png)

.footnote[Martinson, Andreas. « You Should Use This to Visualize SQL Joins Instead of Venn Diagrams ». *Medium* (blog), 4 avril 2022. https://towardsdatascience.com/you-should-use-this-to-visualize-sql-joins-instead-of-venn-diagrams-ede15f9583fc.]

---

```sqlite
SELECT 
    Title,
    Name
FROM 
    albums
INNER JOIN artists 
    ON artists.ArtistId = albums.ArtistId;
```

???

Le choix de la jointure indique la manière dont SQL utilise les données d’une table pour les faire correspondre à d’autres.

```sqlite
SELECT
    Name,
    Title
FROM
    artists
LEFT JOIN albums ON
    artists.ArtistId = albums.ArtistId
WHERE Title IS NULL   
ORDER BY Name;
```



---

## Agrégation

- [Group By](https://www.sqlitetutorial.net/sqlite-group-by/) – combine a set of rows into groups based on specified criteria. The `GROUP BY` clause helps you summarize data for reporting purposes.
- [Having](https://www.sqlitetutorial.net/sqlite-having/) – specify the conditions to filter the groups summarized by the `GROUP BY` clause.

---

## Exemple de `GROUP BY`

```sqlite
SELECT
	albumid,
	COUNT(trackid)
FROM
	tracks
GROUP BY
	albumid;
```

```sqlite
SELECT
	tracks.albumid,
	title,
	COUNT(trackid)
FROM
	tracks
INNER JOIN albums ON albums.albumid = tracks.albumid
GROUP BY
	tracks.albumid;
```

---

```sqlite
INSERT INTO artists (name)
VALUES
	("Buddy Rich"),
	("Candido"),
	("Charlie Byrd");
```

```sqlite
UPDATE employees
SET city = 'Toronto',
    state = 'ON',
    postalcode = 'M5P 2N7'
WHERE
    employeeid = 4;
```

---

## Création de table

```sqlite
CREATE TABLE [IF NOT EXISTS] [schema_name].table_name (
	column_1 data_type PRIMARY KEY,
   	column_2 data_type NOT NULL,
	column_3 data_type DEFAULT 0,
	table_constraints
) [WITHOUT ROWID];
```

---

```sqlite
CREATE TABLE contacts (
	contact_id INTEGER PRIMARY KEY,
	first_name TEXT NOT NULL,
	last_name TEXT NOT NULL,
	email TEXT NOT NULL UNIQUE,
	phone TEXT NOT NULL UNIQUE
);
```

```sqlite
CREATE TABLE groups (
   group_id INTEGER PRIMARY KEY,
   name TEXT NOT NULL
);
```

---

```sqlite
CREATE TABLE contact_groups(
   contact_id INTEGER,
   group_id INTEGER,
   PRIMARY KEY (contact_id, group_id),
   FOREIGN KEY (contact_id) 
      REFERENCES contacts (contact_id) 
         ON DELETE CASCADE 
         ON UPDATE NO ACTION,
   FOREIGN KEY (group_id) 
      REFERENCES groups (group_id) 
         ON DELETE CASCADE 
         ON UPDATE NO ACTION
);
```



---

Enregistrer le résultat d’une requête dans un fichier

```sqlite
.output albums.txt SELECT title FROM albums;
```

Exécuter une déclaration SQL contenue dans un fichier avec `.read`

```sqlite
.read path/to/sql.txt
```

## Créer une table

```sqlite
create table student(
  id int not null,
  firsName varchar(255),
  lastName varchar(255),
  subject varchar(255),
  score int,
  primary key (id)
);
```

Montrer le schéma

```sqlite
.schema
```

Voir la table créée

```sqlite
.table
```

Insérer des données

```sqlite
insert into students values(1, 'Chris', 'Baru', 'Histoire', 97);
insert into students values(2, 'Mark', 'Stern', 'Art', 93);
insert into students values(2, 'David', 'Glass', 'Art', 90);
```

Requêter

```sqlite
select * from students;
```

```sqlite
.headers on
```

```sqlite
.mode column
```



???

https://www.linuxtricks.fr/wiki/sqlite-l-essentiel-sur-cette-base-de-donnees-cli-sql-php

---

# Bibliographie

- Abiteboul, Serge, Peter Buneman, et Dan Suciu. 1999. *Data on the web: from relations to semistructured data and XML*. San Francisco: Morgan Kaufmann.
- Abiteboul, Serge, Richard Hull, et Victor Vianu. 1995. *Foundations of databases*. Reading, Mass: Addison-Wesley.
- Brodie, Michael L. 2018. *Making Databases Work: The Pragmatic Wisdom of Michael Stonebraker*. San Rafael, CA: ACM Books.
- Date, Chris J. 2012. *Database Design and Relational Theory: Normal Forms and All That Jazz*. Theory in Practice. Beijing Köln: O’Reilly.
- Roy, Gilles. 2007. *Conception de bases de données avec UML*. Québec: Presses de l’Université du Québec.
- Schweikard, Nicole, Thomas Schwentick, et Luc Segoufin. 2010. « Database Theory: Query Languages ». In *Algorithms and theory of computation handbook. Special topics and techniques*, édité par Mikhail J. Atallah et Marina Blanton, 2e éd, 19, 1‑34. Chapman & Hall/CRC applied algorithms and data structures series. Boca Raton: CRC Press.

---

## Tutoriaux

- David, Matt. « How to Teach People SQL ». The Data School. Consulté le 5 novembre 2023. https://dataschool.com/how-to-teach-people-sql/.

???

Opération CRUD

ACID
